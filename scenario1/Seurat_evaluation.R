setwd("D:/college/year_3/CMML/ICA2/scenario1")

suppressPackageStartupMessages({
  library(Seurat)
  library(zellkonverter)
  library(SingleCellExperiment)
  library(dplyr)
  library(cluster)
  library(FNN)
  library(lisi)
  library(kBET)
  library(mclust)
  library(aricode)
  library(patchwork)
  library(ggplot2)
})

# === Step 1: load new annotated h5ad ========================================
adata <- readH5AD("Lung_atlas_QCfiltered.h5ad")                 # <-- file name

# â€¢ counts-layer contains raw counts; leave X (log space) aside
# â€¢ data slot (log-normalised) will be generated by Seurat itself
seurat_obj <- as.Seurat(
  adata,
  counts = "counts",     # raw
  data   = NULL          # we'll create fresh logâ€norm data
)
rm(adata); gc()

# === Step 2: basic Seurat prep (no external annotation) =====================
DefaultAssay(seurat_obj) <- "originalexp"

# pick top 3 000 HVGs instead of using every gene
seurat_obj <- FindVariableFeatures(seurat_obj, nfeatures = 3000)  ### NEW_DATASET

# standard workflow
seurat_obj <- NormalizeData(seurat_obj)
seurat_obj <- ScaleData(seurat_obj)
seurat_obj <- RunPCA(seurat_obj, npcs = 30, reduction.name = "pca_before")
seurat_obj <- RunUMAP(seurat_obj, dims = 1:30, reduction = "pca_before",
                      reduction.name = "umap_before")

# graph clustering (same resolution for raw & integrated)
seurat_obj <- FindNeighbors(seurat_obj, reduction = "pca_before", dims = 1:30)
seurat_obj <- FindClusters(seurat_obj, resolution = 0.05)

# === Step 3: choose the batch column intelligently ==========================
batch_col <- if ("batch" %in% colnames(seurat_obj@meta.data)) "batch" else "dataset"

# === Step 4: build meta + embedding list for RAW ============================
meta_data <- seurat_obj@meta.data |>
  mutate(
    cell_id   = colnames(seurat_obj),
    dataset   = .data[[batch_col]],   ### NEW_DATASET
    nGene     = nFeature_originalexp,
    cell_type = cell_type,
    cluster   = seurat_clusters
  )

cell_lines <- list(
  meta_data = meta_data,
  scaled_pcs = Embeddings(seurat_obj, reduction = "pca_before")
)

# === Step 5: Seurat integration on the chosen batch column ==================
seurat_list <- SplitObject(seurat_obj, split.by = batch_col)
seurat_list <- lapply(seurat_list, NormalizeData)          # keep same pipeline
seurat_list <- lapply(seurat_list, FindVariableFeatures, nfeatures = 3000)

anchors <- FindIntegrationAnchors(seurat_list, dims = 1:30)
rm(seurat_list); gc()
seurat_integrated <- IntegrateData(anchorset = anchors, dims = 1:30)
rm(anchors); gc()

DefaultAssay(seurat_integrated) <- "integrated"
seurat_integrated <- ScaleData(seurat_integrated)
seurat_integrated <- RunPCA(seurat_integrated, npcs = 30)
seurat_integrated <- RunUMAP(seurat_integrated, dims = 1:30)
seurat_integrated <- FindNeighbors(seurat_integrated, dims = 1:30)
seurat_integrated <- FindClusters(seurat_integrated, resolution = 0.05)

# ====== Step 6: meta + embedding for INTEGRATED =============================
meta_data_int <- seurat_integrated@meta.data |>
  mutate(
    cell_id   = colnames(seurat_integrated),
    dataset   = .data[[batch_col]],
    nGene     = nFeature_originalexp,
    cell_type = cell_type,
    cluster   = seurat_clusters
  )

cell_lines_integrated <- list(
  meta_data = meta_data_int,
  scaled_pcs = Embeddings(seurat_integrated, reduction = "pca")
)

save_umap <- function(obj, file, reduction = "umap", extra.cols = c("batch", "cell_type")) {
  stopifnot(inherits(obj, "Seurat"))
  df <- FetchData(obj, vars = c(paste0(reduction, "_1"),
                                paste0(reduction, "_2"),
                                extra.cols))
  colnames(df)[1:2] <- c("UMAP_1", "UMAP_2")
  df$method <- basename(tools::file_path_sans_ext(file))   # tag for later facets
  saveRDS(df, file = file, compress = "xz")
  invisible(df)
}

save_umap(seurat_obj,
          file = "umap_raw.rds",
          reduction = "umapbefore",              # change if you renamed the slot
          extra.cols = c("batch", "cell_type"))

save_umap(seurat_integrated,
          file = "umap_seurat_integrated.rds",
          reduction = "umap",              # change if you renamed the slot
          extra.cols = c("batch", "cell_type"))

# === Step 7: benchmarking helper ============================================
benchmark_metrics <- function(cell_lines, label = "Method", output_csv = "benchmark_results.csv") {
  cat("\n====", label, "====\n")
  embedding <- cell_lines$scaled_pcs
  meta <- cell_lines$meta_data[match(rownames(embedding), cell_lines$meta_data$cell_id), ]
  k <- 30
  
  lisi <- compute_lisi(embedding, meta, c("dataset", "cell_type"))
  mean_ilisi <- round(mean(lisi$dataset), 3)
  mean_clisi <- round(mean(lisi$cell_type), 3)
  
  sil_ct <- silhouette(as.numeric(factor(meta$cell_type)), dist(embedding))
  sil_batch <- silhouette(as.numeric(factor(meta$dataset)), dist(embedding))
  asw_ct <- round(mean(sil_ct[, "sil_width"]), 3)
  asw_batch <- round(mean(sil_batch[, "sil_width"]), 3)
  
  knn <- get.knn(embedding, k = k)
  knn_mix <- round(mean(sapply(seq_len(nrow(embedding)), function(i) {
    mean(meta$dataset[knn$nn.index[i, ]] != meta$dataset[i])
  })), 3)
  
  r2_pcr <- round(mean(sapply(seq_len(ncol(embedding)), function(j) {
    summary(lm(embedding[, j] ~ meta$dataset))$r.squared
  })), 3)
  
  isolated_label <- round(mean(sapply(seq_len(nrow(embedding)), function(i) {
    mean(meta$cell_type[knn$nn.index[i, ]] == meta$cell_type[i])
  })), 3)
  
  nmi <- round(NMI(meta$cell_type, meta$cluster, variant = "sqrt"), 3)
  ari <- round(adjustedRandIndex(meta$cell_type, meta$cluster), 3)
  
  # Print results
  cat("ðŸ§ª mean iLISI:", mean_ilisi, "\n")
  cat("ðŸ§¬ mean cLISI:", mean_clisi, "\n")
  cat("ðŸ“ ASW (cell type):", asw_ct, "\n")
  cat("ðŸ§¯ ASW (batch):", asw_batch, "\n")
  cat("ðŸ”— kNN Graph Connectivity:", knn_mix, "\n")
  cat("ðŸ§ª Mean RÂ² from PCR:", r2_pcr, "\n")
  cat("ðŸ§¬ Isolated Label Score:", isolated_label, "\n")
  cat("ðŸ“Š NMI (cell type vs. cluster):", nmi, "\n")
  cat("ðŸ“Š ARI (cell type vs. cluster):", ari, "\n")
  
  # Store in data frame
  res <- data.frame(
    Method = label,
    mean_iLISI = mean_ilisi,
    mean_cLISI = mean_clisi,
    ASW_celltype = asw_ct,
    ASW_batch = asw_batch,
    kNN_batch_mix = knn_mix,
    PCR_R2 = r2_pcr,
    Isolated_Label = isolated_label,
    NMI = nmi,
    ARI = ari,
    stringsAsFactors = FALSE
  )
  
  # Write (append if exists)
  if (!file.exists(output_csv)) {
    write.csv(res, output_csv, row.names = FALSE)
  } else {
    write.table(res, output_csv, sep = ",", row.names = FALSE, col.names = FALSE, append = TRUE)
  }
}

# === Step 8: run ============================================================
benchmark_metrics(cell_lines,              label = "Raw (Unintegrated)")
benchmark_metrics(cell_lines_integrated,   label = "Seurat Integrated")

library(SeuratDisk)

raw_slim <- DietSeurat(
  object   = seurat_obj,                 # raw object
  assays   = "originalexp",
  layers   = list(originalexp = "counts"),       # keep only counts layer
  features = VariableFeatures(seurat_obj),
  dimreducs = c("pca_before", "umap_before")
)

SaveH5Seurat(raw_slim, "processed/lung_raw_slim.h5seurat", overwrite = TRUE)   # :contentReference[oaicite:2]{index=2}

## ---- slim down INTEGRATED ---------------------------------------------------
int_slim <- DietSeurat(
  object   = seurat_integrated,
  assays   = c("originalexp", "integrated"),
  layers   = list(
    integrated  = "data",   # corrected log-norm values
    originalexp = "counts"  # optional raw counts
  ),
  dimreducs = c("pca", "umap")
)

SaveH5Seurat(int_slim, "processed/lung_seurat_integrated_slim.h5seurat", overwrite = TRUE)
